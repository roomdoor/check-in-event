# Check-in Event Service 🚀

이 프로젝트는 **대규모 이벤트 체크인 트래픽**을 안정적으로 처리하기 위한 백엔드 시스템입니다.
DB 락 기반의 동기 처리와 Redis 기반의 비동기 처리 성능을 단계별 부하 테스트를 통해 비교 검증했습니다.

---

## 📊 부하 테스트 결과 상세 비교

테스트는 시스템의 기초 성능을 확인하는 **500 RPS** 단계와, 시스템의 한계를 시험하는 **2000 RPS** 단계로 나누어 진행되었습니다.

### 1단계: 500 RPS 테스트 (기초 처리량 검증)
두 방식 모두 목표 처리량을 달성했으나, 응답 시간에서 Redis 방식이 월등히 빠른 수치를 기록했습니다.

| 지표 | DB Lock (Sync) | Redis Async (비동기) | 격차 |
| :--- | :--- | :--- | :--- |
| **실제 처리량** | **499.32 RPS** | **499.98 RPS** | 동일 수준 |
| **평균 응답 시간** | 24.89ms | **1.97ms** | **약 12.6배 차이** |
| **P95 지연 시간** | 123.6ms | **2.1ms** | **약 58배 차이** |
| **Dropped Iters** | 39건 | **0건** | - |

---

### 2단계: 2000 RPS 테스트 (임계치 및 병목 지점 확인)
부하를 4배 높였을 때, DB 방식은 처리에 한계를 보이며 대부분의 요청이 유실되었습니다.

| 지표 | DB Lock (Sync) | Redis Async (비동기) | 격차 |
| :--- | :--- | :--- | :--- |
| **실제 처리량** | **505.82 RPS** | **1,987.08 RPS** | **약 3.9배 차이** |
| **평균 응답 시간** | 393.11ms | **5.79ms** | **약 67배 차이** |
| **P95 지연 시간** | 500.33ms | **17.1ms** | **약 29배 차이** |
| **Dropped Iters** | 89,439건 | **768건** | **안정성 압승** |

---

## 🔍 결과 분석 및 해석

### 1. 처리량(Throughput)의 한계점 발견
* **DB 방식:** 500 RPS에서 2000 RPS로 요청량을 늘려도 실제 처리량은 **505 RPS** 내외에 머물렀습니다. 이는 시스템의 DB 트랜잭션 처리 한계가 500 RPS임을 명확히 보여줍니다.
* **Redis 방식:** 동일한 고부하 상황에서도 목표치(2000 RPS)를 거의 모두 수용하며 선형적인 성능 확장을 증명했습니다.



### 2. 지연 시간(Latency) 안정성
* DB 방식은 부하가 증가함에 따라 P95 지연 시간이 **123ms에서 500ms**로 4배 이상 급증했습니다.
* Redis 방식은 부하가 4배 증가했음에도 P95 지연 시간이 **17.1ms** 수준으로 억제되어 매우 안정적인 사용자 경험을 제공합니다.

### 3. Dropped Iterations (요청 유실)의 의미
* DB 방식에서 발생한 대량의 유실은 요청이 서버의 커넥션 풀(Connection Pool)이나 워커 스레드(Worker Thread)에서 처리되지 못하고 대기하다가 타임아웃되어 버려졌음을 의미합니다.
* Redis 방식은 메모리 기반의 비동기 큐잉을 통해 이러한 병목을 해소하고 요청을 안정적으로 수용했습니다.

---

## 🛠 실행 환경 및 설정
* **Tool:** k6 (Scenario: `constant-arrival-rate`)
- **Environment:** Local PC
- **VUs:** `PRE_VUS=50`, `MAX_VUS=200`
- **Command:**
```bash
# DB 모드 2000 RPS 테스트
k6 run -e MODE=db -e RATE=2000 -e DURATION=1m loadtest/checkin.js

# Redis 모드 2000 RPS 테스트
k6 run -e MODE=redis -e RATE=2000 -e DURATION=1m loadtest/checkin.js